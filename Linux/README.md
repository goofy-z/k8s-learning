[toc]



### 1. 一些环境信息

$(uname) = Linux

#### 1.1 cpu信息

物理cpu个数： `cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l`

逻辑cpu个数：`cat /proc/cpuinfo | grep "processor" | wc -l`

物理cpu核数：`cat /proc/cpuinfo | grep "cpu cores"`

逻辑cpu核数：`cat /proc/cpuinfo | grep "cpu cores"`

### 2. linux上数据从文件到socket的数据流向

- 操作系统把数据从文件系统拷贝内核中的页缓存
- 应用程序从页缓存把数据拷贝到自己的内存缓存中（堆上）
- 应用程序将数据写入到内核socket缓存中
- 操作系统把数据从socket缓存拷贝到网卡接口缓存

### 3. linux下的进程状态

- R(TASK_RUNNING) 可执行状态&运行状态(run_queue队列的状态)
- S(TASK_INTERRUPTIBLE) 可中断的睡眠状态, 可处理signal
- D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态,　可处理signal,　有延迟
- T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。
- Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。

### 4. 用户态和内核态

- 特权级

  用户态和内核态是按照特权级（0-3）级来区分的，之所以要有一个特权级，是因为一些高级操作，关键性操作不能把权限放低到任何进程都能直接去进行，需要统一来避免有限资源频繁访问和冲突，并按照这种关键性程度划分级别，0级最低称为用户态

- 用户态切换到内核态

  a. 系统调用

  ​	主动切换内核态，使用操作系统提供的服务，其核心还是使用了中断

  b. 异常

  ​	cpu执行用户程序发生了一些异常，比如缺页异常，会切换到内核态处理该异常的相关程序

  c. 外围设备中断

  ​	当外围设备完成用户请求后，会发起中断信号，这时候cpu就会去执行中断程序，这个是内核态的程序，如果先前执行的是用户态程序，就会发生切换

- cpu切换

  每次系统调用，CPU需要保存原有的用户态指令然后执行内核态指令，调用结束又要恢复用户态，所以一次系统调用会发生两次cpu上下文切换。

  系统调用并不会涉及到虚拟内存等进程用户态资源，也不会切换进程。进程的上下文不仅包含了虚拟内存、栈。全局变量等用户空间的资源，还包含了内核堆栈、寄存器等内核空间状态。

- 进程切换

  进程切换时需要切换上下文，这个过程会进行寄存器、内核栈、以及虚拟内存等资源的保存和恢复。在进程切换中

  1. 时间片被耗尽，进程就会被系统挂起，切换其它进程。
  2. 进程的系统资源不足（比如内存不足），会被挂起，等到资源满足，这个时候会切换。
  3. 睡眠函数会切换进程，sleep会将自己主动挂起。
  4. 优先级更高的进程，当前进程会被挂起
  5. 发生硬件中断，CPU上的进程会被中断挂起，转而执行内核中中断服务程序。

- 线程切换

  内核中的任务调用，实际上的调度对象是线程,而进程只是给线程提供了虚拟内存、全局变量等资源

  - 当进程只有一个线程时，可以认为进程就等于线程
  - 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源
  - 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

  线程切换分为两种情况

  1. 前后俩个线程属于不同进程，此时，由于资源不共享，所以切换过程就跟进程上下文切换是一样的。

  2. 前后两个线程属于同一个进程，此时，应为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据，寄存器等不共享的数据。

  所以多线程的切换资源消耗是最少的

- 中断上下文切换

  因为不涉及进程的用户态切换，所以不会切换虚拟内存、全局变量等用户资源。只包括CPU寄存器、内核堆栈、硬件中断等参数。
  
  

### 5. 一些命令用法

- curl命令

  -X 使用当前系统的代理；

  -d: “a=1&b=c”  携带数据

  -H: “Content-Type: application/json; charset=utf-8”  设置请求头

- 服务器文件传输

  sftp root@xxxxxxx 

  Scp xxx.txt root@IP:/root 
  
- 转base64，并去掉换行符

  cat /root/.ssh/id_rsa|base64|tr -d \\n 
  
- TOP

  **load average**:  1、5、15分钟运行队列中平均进程数量

  **Cpu(s)**: us: 用户进程占用整个cpu对的平均值，在top下按1能看到多个cpu使用情况。

  **%CPU**：上次更新到现在的CPU时间占用百分比，占用一个核，如果大于100，代表用多线程操作了多个核。

### 6. iptables 防火墙

policy drop 为禁用规则，所有的udp，tcp都不允许

Chain INPUT (policy ACCEPT) 入链 

Chain OUTPUT (policy ACCEPT) 出链

iptables -t nat -D POSTROUTING 3 删除链

iptables -F 会清除所有的出入链规则

iptables -X 清空自定义链

Iptables-save > xxxx.ip 保存 iptables 

Iptables-restore 保存 iptables 

下载nslookup : `apt-get install dnsutils`

### 7. 堆栈

- 堆可以动态分配内存，栈必须实现声明数据大小和生命周期

- 堆取数较慢，栈取数快

- 栈中一些相同的值的变量会共享同一块地址

- 栈是有编译器自己分配和释放空间 声明局部变量 int a在栈中为b开辟空间

- 堆则由程序员自己释放 malloc申请堆中内存

### 8. IO模型

- 阻塞IO模型

  线程发出IO请求，内核会去查看数据是否就绪，没有就绪，用户线程就会处于阻塞状态，用户线程交出CPU。

- 非阻塞IO模型

  用户线程发起IO操作后，不需要等待，马上就得到一个结果，结果会返回数据是否准备好

- I/O 多路复用

  通过一种机制使一个进程能同时等待多个文件描述符进入就绪状态，两次system call (select 和 recvfrom)。这种模型并不是为了更快的处理单个连接，而是在于处理更多的连接，且一个线程就能处理多个连接。

- 信号驱动 I/O

  当用户线程发起一个IO请求操作,然后对应的socket注册一个信号函数，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作，一般用于UDP。

- 异步 I/O

  当用户线程发起IO操作，IO操作的两个阶段（等待数据就绪和内核拷贝数据到用户空间）都不会阻塞用户线程，均由内核完成，然后发送一个信号告知用户线程操作完成。和信号驱动I/O不同的点是，用户线程不需要调用IO函数进行实际读写操作。而异步IO中，当收到信号时，IO操作已经完成，不用再调用IO函数。

### 9. 线程模型

一个线程的构成 ： 计数器 一组寄存器 栈

线程的实现模型主要由3种：内核级线程模型、用户级线程模型、混合型线程模型。他们最大的区别在于线程与内核调度实体KSE（Kernel Scheduling Entity）之间的对应关系，可以被操作系统内核调度的对象实体，也称为内核级线程，操作系统内核最小调度单元

- 内核级线程模型

  用户线程和KSE 1:1的关系，大部分编程语言的线程库都是对操作系统的KSE的封装，调度工作完全由OS调度器来做，实现方式简单。

- 用户级线程模型

  用户线程和KSE M:1的关系，这种线程的创建、销毁以及多个线程之间的协调都是由用户自己的线程库负责的，这也就是协程实现的方式。这种方式下，创建线程的数量和上下文切换所消耗的资源代价会很小。但是有缺点：当我们在某个用户线程发起了阻塞的系统调用（阻塞方式read网络IO），导致线程阻塞这种情况下KSE就会发生阻塞，当内核线程发生阻塞那么cpu将会将当前KSE挂起，对应的用户线程全部变为阻塞状态。

  要解决这种问题，常见的就是用户线程里做文章，一旦发生了阻塞的操作，就主动让出当前的用户线程，执行下一个线程，从而避免KSE阻塞。类似python的gevent使用时需要打上一个monkey_patch封装IO操作。

- 混合型线程模型

  用户线程和KSE M:N的关系，在一个进程中创建多个KSE，并且线程可以与不同的KSE关联，所以当某一个KSE执行一个阻塞的用户线程的被挂起的时候，与该KSE绑定的其它用户线程将会被分配到其它的KSE，这种动态关联机制时用户实现的，比如go就是实现了该模型，**用户调度器实现用户线程到KSE的“调度”，内核调度器实现KSE到CPU上的调度**

### 10. vim操作

#### 复制粘贴

命令模式下，

- **yy**复制当前光标行，**2yy**复制当前之后两行

- **p**粘贴复制行

#### 删除

命令模式下，

- 删除一行 **d d**
- 删除字符 **x**
- 删除光标后的字符 **d$**, **d0**删到行首
- 删除光标当前后的一个字符 **dw**
- 

###11. she l l

for循环：

```shell
for i in `env`;
do
	xxx
done
```

if判断

```shell
if [[ $i == OJ_* ]];
then
	name=${i%=*} # 取=号左边的 http://c.biancheng.net/view/1120.html
fi
```

```shell
#/bin/bash
JUDGE_PATH="/home/judge/etc/judge.conf"
for i in `env`;
do
        if [[ $i == OJ_* ]];
        then
                name=${i%=*}
                echo $name
                #sed "s/OJ_HOST_NAME=.*/$i/g" $JUDGE_PATH
        fi
done
```



### 12. nginx

client_max_body_size 为每一个server设置body的最大值，默认1M

### 13. 硬件

物理CPU:物理CPU是相对于虚拟CPU而言的概念，指实际存在的处理器,就是我们可以看的见，摸得着的CPU，就是插在主板上面的。

物理核：CPU中包含的物理内核个数，比如我们通常说的双核CPU，单核CPU。这个呢有点看不见摸不着，已经集成在CPU内部了。在linux系统下面的/proc/cpuinfo文件的条目中：1.有多少个不同的physical id就有多少个物理CPU。2.cpu cores记录了对应的物理CPU（以该条目中的physical id标识）有多少个物理核，现在我们个人使用的单机PC大部分使用的都是双核CPU。

逻辑CPU（逻辑核）：用Intel的超线程技术(HT)将物理核虚拟而成的逻辑处理单元,现在大部分的主机的CPU都在使用HT技术，我们在windows系统下面看下图，我们看到有4个cpu记录，其实我们使用的双核CPU只是使用HT技术虚拟出来4个逻辑CPU.在linux系统下面的/proc/cpuinfo文件的条目中siblings记录了对应的物理CPU（以该条目中的physical id标识）有多少个逻辑核。

vCPU:虚拟cpu是我们在做虚拟化时候，利用虚拟化技术，虚拟出来的CPU。讨论vCPU离不开VM，因此vCPU的讨论都是在虚拟化时候，划分cpu才会讨论的问题。通常一个物理CPU按照1:4——1：10的比例划分，假如我们有4个8物理核心的CPU按照1:5的比例划分，可以得到4X8X5=160vCPU.

### 14. nfs

Mount nfs服务

首先查看pv指定的server





### 15. nginx

nginx默认是把每一个请求的body接收完后再发送给upstream

proxy_request_buffering 关闭缓冲，主要是为了流式上传

```
location /static/{
    add_header Content-Disposition "attachment;"; 给所有请求加上请求头
    alias   /uploads/local_storage/;
  }
```





### 16. 批量移动目录

```
ls -lrt |grep "Jun 21"|awk -F " " '{print $9}'|xargs -I file mv file ../../backup-user/
```

###17. swap分区、缓存、buffer

#### swap

Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，这部分内存就是Cache Memory(缓存内存)。即使你的程序运行结束后，Cache Memory也不会自动释放。这就会导致你在Linux系统中程序频繁读写文件后，你会发现可用物理内存变少。当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap空间中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行Swap交换

临时永久停止： `swapoff -a `

永久停止：在/etc/fstab 中注释掉swap一行

####Buffer/Cache

buffer/cached是为了提高文件读取的性能，cache会缓存文件内存，buffer缓存文件元信息

### 18. linux问题

#### 执行各种命令都提示fork: Cannot allocate memory

实际内存空闲很多。是因为进程数超最大值了

解决：

- 查看当前系统进程数 `ps -eLf | wc -l`

- 查看系统内核默认进程数`sysctl kernel.pid_max`

- 如果是超内核进程数限制了，修改系统内核最大进程数 `sysctl -w kernel.pid_max=65535`

- 查看ulimit中最大进程数 `ulimit -u`

- 查看系统最大线程数限制 `cat /proc/sys/kernel/threads-max`

- 查看占用线程最多的进程 `ps -efL | awk '{print $10}' |sort|uniq -c | sort -nr | less`

  